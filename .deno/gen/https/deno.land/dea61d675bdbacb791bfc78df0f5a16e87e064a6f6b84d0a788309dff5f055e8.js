import { delay } from "./utils.ts";
export function createLeakyBucket({ max , refillInterval , refillAmount , tokens , waiting , ...rest }) {
    return {
        max,
        refillInterval,
        refillAmount: refillAmount > max ? max : refillAmount,
        lastRefill: performance.now(),
        allowAcquire: true,
        nextRefill: function() {
            return nextRefill(this);
        },
        tokens: function() {
            return updateTokens(this);
        },
        acquire: async function(amount, highPriority) {
            return await acquire(this, amount, highPriority);
        },
        tokensState: tokens ?? max,
        waiting: waiting ?? [],
        ...rest
    };
}
/** Update the tokens of that bucket.
 * @returns {number} The amount of current available tokens.
 */ function updateTokens(bucket) {
    const timePassed = performance.now() - bucket.lastRefill;
    const missedRefills = Math.floor(timePassed / bucket.refillInterval);
    // The refill shall not exceed the max amount of tokens.
    bucket.tokensState = Math.min(bucket.tokensState + bucket.refillAmount * missedRefills, bucket.max);
    bucket.lastRefill += bucket.refillInterval * missedRefills;
    return bucket.tokensState;
}
function nextRefill(bucket) {
    // Since this bucket is lazy update the tokens before calculating the next refill.
    updateTokens(bucket);
    return performance.now() - bucket.lastRefill + bucket.refillInterval;
}
async function acquire(bucket, amount, highPriority = false) {
    // To prevent the race condition of 2 acquires happening at once,
    // check whether its currently allowed to acquire.
    if (!bucket.allowAcquire) {
        // create, push, and wait until the current running acquiring is finished.
        await new Promise((resolve)=>{
            if (highPriority) {
                bucket.waiting.unshift(resolve);
            } else {
                bucket.waiting.push(resolve);
            }
        });
        // Somehow another acquire has started,
        // so need to wait again.
        if (!bucket.allowAcquire) {
            return await acquire(bucket, amount);
        }
    }
    bucket.allowAcquire = false;
    // Since the bucket is lazy update the tokens now,
    // and also get the current amount of available tokens
    let currentTokens = updateTokens(bucket);
    // It's possible that more than available tokens have been acquired,
    // so calculate the amount of milliseconds to wait until this acquire is good to go.
    if (currentTokens < amount) {
        const tokensNeeded = amount - currentTokens;
        let refillsNeeded = Math.ceil(tokensNeeded / bucket.refillAmount);
        const waitTime = bucket.refillInterval * refillsNeeded;
        await delay(waitTime);
        // Update the tokens again to ensure nothing has been missed.
        updateTokens(bucket);
    }
    // In order to not subtract too much from the tokens,
    // calculate what is actually needed to subtract.
    const toSubtract = amount % bucket.refillAmount || amount;
    bucket.tokensState -= toSubtract;
    // Allow the next acquire to happen.
    bucket.allowAcquire = true;
    // If there is an acquire waiting, let it continue.
    bucket.waiting.shift()?.();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQaWNrUGFydGlhbCB9IGZyb20gXCIuLi90eXBlcy9zaGFyZWQudHNcIjtcbmltcG9ydCB7IGRlbGF5IH0gZnJvbSBcIi4vdXRpbHMudHNcIjtcblxuLyoqIEEgTGVha3kgQnVja2V0LlxuICogVXNlZnVsIGZvciByYXRlIGxpbWl0aW5nIHB1cnBvc2VzLlxuICogVGhpcyB1c2VzIGBwZXJmb3JtYW5jZS5ub3coKWAgaW5zdGVhZCBvZiBgRGF0ZS5ub3coKWAgZm9yIGhpZ2hlciBhY2N1cmFjeS5cbiAqXG4gKiBOT1RFOiBUaGlzIGJ1Y2tldCBpcyBsYXp5LCBtZWFucyBpdCBvbmx5IHVwZGF0ZXMgd2hlbiBhIHJlbGF0ZWQgbWV0aG9kIGlzIGNhbGxlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMZWFreUJ1Y2tldCB7XG4gIC8vIC0tLS0tLS0tLS1cbiAgLy8gUFJPUEVSVElFU1xuICAvLyAtLS0tLS0tLS0tXG5cbiAgLyoqIEhvdyBtYW55IHRva2VucyB0aGlzIGJ1Y2tldCBjYW4gaG9sZC4gKi9cbiAgbWF4OiBudW1iZXI7XG4gIC8qKiBBbW91bnQgb2YgdG9rZW5zIGdhaW5lZCBwZXIgaW50ZXJ2YWwuXG4gICAqIElmIGJpZ2dlciB0aGFuIGBtYXhgIGl0IHdpbGwgYmUgcHJlc3NlZCB0byBgbWF4YC5cbiAgICovXG4gIHJlZmlsbEFtb3VudDogbnVtYmVyO1xuICAvKiogSW50ZXJ2YWwgYXQgd2hpY2ggdGhlIGJ1Y2tldCBnYWlucyB0b2tlbnMuICovXG4gIHJlZmlsbEludGVydmFsOiBudW1iZXI7XG5cbiAgLy8gLS0tLS0tLS0tLVxuICAvLyBNRVRIT0RTXG4gIC8vIC0tLS0tLS0tLS1cblxuICAvKiogQWNxdWlyZSB0b2tlbnMgZnJvbSB0aGUgYnVja2V0LlxuICAgKiBSZXNvbHZlcyB3aGVuIHRoZSB0b2tlbnMgYXJlIGFjcXVpcmVkIGFuZCBhdmFpbGFibGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpZ2hQcmlvcml0eT1mYWxzZV0gV2hldGhlciB0aGlzIGFjcXVpcmUgaXMgc2hvdWxkIGJlIGRvbmUgYXNhcC5cbiAgICovXG4gIGFjcXVpcmUoYW1vdW50OiBudW1iZXIsIGhpZ2hQcmlvcml0eT86IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHVudGlsIHRoZSBuZXh0IHJlZmlsbC4gKi9cbiAgbmV4dFJlZmlsbCgpOiBudW1iZXI7XG5cbiAgLyoqIEN1cnJlbnQgdG9rZW5zIGluIHRoZSBidWNrZXQuICovXG4gIHRva2VucygpOiBudW1iZXI7XG5cbiAgLy8gLS0tLS0tLS0tLVxuICAvLyBJTlRFUk5BTCBTVEFURVNcbiAgLy8gLS0tLS0tLS0tLVxuXG4gIC8qKiBAcHJpdmF0ZSBJbnRlcm5hbCB0cmFjayBvZiB3aGVuIHRoZSBsYXN0IHJlZmlsbCBvZiB0b2tlbnMgd2FzLlxuICAgKiBETyBOT1QgVE9VQ0ggVEhJUyEgVW5sZXNzIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZyBvZmMgOlBcbiAgICovXG4gIGxhc3RSZWZpbGw6IG51bWJlcjtcblxuICAvKiogQHByaXZhdGUgSW50ZXJuYWwgc3RhdGUgb2Ygd2hldGhlciBjdXJyZW50bHkgaXQgaXMgYWxsb3dlZCB0byBhY3F1aXJlIHRva2Vucy5cbiAgICogRE8gTk9UIFRPVUNIIFRISVMhIFVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcgb2ZjIDpQXG4gICAqL1xuICBhbGxvd0FjcXVpcmU6IGJvb2xlYW47XG5cbiAgLyoqIEBwcml2YXRlIEludGVybmFsIG51bWJlciBvZiBjdXJyZW50bHkgYXZhaWxhYmxlIHRva2Vucy5cbiAgICogRE8gTk9UIFRPVUNIIFRISVMhIFVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcgb2ZjIDpQXG4gICAqL1xuICB0b2tlbnNTdGF0ZTogbnVtYmVyO1xuXG4gIC8qKiBAcHJpdmF0ZSBJbnRlcm5hbCBhcnJheSBvZiBwcm9taXNlcyBuZWNlc3NhcnkgdG8gZ3VhcmFudGVlIG5vIHJhY2UgY29uZGl0aW9ucy5cbiAgICogRE8gTk9UIFRPVUNIIFRISVMhIFVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcgb2ZjIDpQXG4gICAqL1xuICB3YWl0aW5nOiAoKF8/OiB1bmtub3duKSA9PiB2b2lkKVtdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGVha3lCdWNrZXQoXG4gIHsgbWF4LCByZWZpbGxJbnRlcnZhbCwgcmVmaWxsQW1vdW50LCB0b2tlbnMsIHdhaXRpbmcsIC4uLnJlc3QgfTpcbiAgICAmIE9taXQ8XG4gICAgICBQaWNrUGFydGlhbDxcbiAgICAgICAgTGVha3lCdWNrZXQsXG4gICAgICAgIFwibWF4XCIgfCBcInJlZmlsbEludGVydmFsXCIgfCBcInJlZmlsbEFtb3VudFwiXG4gICAgICA+LFxuICAgICAgXCJ0b2tlbnNcIlxuICAgID5cbiAgICAmIHtcbiAgICAgIC8qKiBDdXJyZW50IHRva2VucyBpbiB0aGUgYnVja2V0LlxuICAgICAgICogQGRlZmF1bHQgbWF4XG4gICAgICAgKi9cbiAgICAgIHRva2Vucz86IG51bWJlcjtcbiAgICB9LFxuKTogTGVha3lCdWNrZXQge1xuICByZXR1cm4ge1xuICAgIG1heCxcbiAgICByZWZpbGxJbnRlcnZhbCxcbiAgICByZWZpbGxBbW91bnQ6IHJlZmlsbEFtb3VudCA+IG1heCA/IG1heCA6IHJlZmlsbEFtb3VudCxcbiAgICBsYXN0UmVmaWxsOiBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICBhbGxvd0FjcXVpcmU6IHRydWUsXG5cbiAgICBuZXh0UmVmaWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV4dFJlZmlsbCh0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9rZW5zOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdXBkYXRlVG9rZW5zKHRoaXMpO1xuICAgIH0sXG5cbiAgICBhY3F1aXJlOiBhc3luYyBmdW5jdGlvbiAoYW1vdW50LCBoaWdoUHJpb3JpdHkpIHtcbiAgICAgIHJldHVybiBhd2FpdCBhY3F1aXJlKHRoaXMsIGFtb3VudCwgaGlnaFByaW9yaXR5KTtcbiAgICB9LFxuXG4gICAgdG9rZW5zU3RhdGU6IHRva2VucyA/PyBtYXgsXG4gICAgd2FpdGluZzogd2FpdGluZyA/PyBbXSxcblxuICAgIC4uLnJlc3QsXG4gIH07XG59XG5cbi8qKiBVcGRhdGUgdGhlIHRva2VucyBvZiB0aGF0IGJ1Y2tldC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBhbW91bnQgb2YgY3VycmVudCBhdmFpbGFibGUgdG9rZW5zLlxuICovXG5mdW5jdGlvbiB1cGRhdGVUb2tlbnMoYnVja2V0OiBMZWFreUJ1Y2tldCk6IG51bWJlciB7XG4gIGNvbnN0IHRpbWVQYXNzZWQgPSBwZXJmb3JtYW5jZS5ub3coKSAtIGJ1Y2tldC5sYXN0UmVmaWxsO1xuICBjb25zdCBtaXNzZWRSZWZpbGxzID0gTWF0aC5mbG9vcih0aW1lUGFzc2VkIC8gYnVja2V0LnJlZmlsbEludGVydmFsKTtcblxuICAvLyBUaGUgcmVmaWxsIHNoYWxsIG5vdCBleGNlZWQgdGhlIG1heCBhbW91bnQgb2YgdG9rZW5zLlxuICBidWNrZXQudG9rZW5zU3RhdGUgPSBNYXRoLm1pbihidWNrZXQudG9rZW5zU3RhdGUgKyAoYnVja2V0LnJlZmlsbEFtb3VudCAqIG1pc3NlZFJlZmlsbHMpLCBidWNrZXQubWF4KTtcbiAgYnVja2V0Lmxhc3RSZWZpbGwgKz0gYnVja2V0LnJlZmlsbEludGVydmFsICogbWlzc2VkUmVmaWxscztcblxuICByZXR1cm4gYnVja2V0LnRva2Vuc1N0YXRlO1xufVxuXG5mdW5jdGlvbiBuZXh0UmVmaWxsKGJ1Y2tldDogTGVha3lCdWNrZXQpOiBudW1iZXIge1xuICAvLyBTaW5jZSB0aGlzIGJ1Y2tldCBpcyBsYXp5IHVwZGF0ZSB0aGUgdG9rZW5zIGJlZm9yZSBjYWxjdWxhdGluZyB0aGUgbmV4dCByZWZpbGwuXG4gIHVwZGF0ZVRva2VucyhidWNrZXQpO1xuXG4gIHJldHVybiAocGVyZm9ybWFuY2Uubm93KCkgLSBidWNrZXQubGFzdFJlZmlsbCkgKyBidWNrZXQucmVmaWxsSW50ZXJ2YWw7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGFjcXVpcmUoYnVja2V0OiBMZWFreUJ1Y2tldCwgYW1vdW50OiBudW1iZXIsIGhpZ2hQcmlvcml0eSA9IGZhbHNlKTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIFRvIHByZXZlbnQgdGhlIHJhY2UgY29uZGl0aW9uIG9mIDIgYWNxdWlyZXMgaGFwcGVuaW5nIGF0IG9uY2UsXG4gIC8vIGNoZWNrIHdoZXRoZXIgaXRzIGN1cnJlbnRseSBhbGxvd2VkIHRvIGFjcXVpcmUuXG4gIGlmICghYnVja2V0LmFsbG93QWNxdWlyZSkge1xuICAgIC8vIGNyZWF0ZSwgcHVzaCwgYW5kIHdhaXQgdW50aWwgdGhlIGN1cnJlbnQgcnVubmluZyBhY3F1aXJpbmcgaXMgZmluaXNoZWQuXG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGlmIChoaWdoUHJpb3JpdHkpIHtcbiAgICAgICAgYnVja2V0LndhaXRpbmcudW5zaGlmdChyZXNvbHZlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1Y2tldC53YWl0aW5nLnB1c2gocmVzb2x2ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTb21laG93IGFub3RoZXIgYWNxdWlyZSBoYXMgc3RhcnRlZCxcbiAgICAvLyBzbyBuZWVkIHRvIHdhaXQgYWdhaW4uXG4gICAgaWYgKCFidWNrZXQuYWxsb3dBY3F1aXJlKSB7XG4gICAgICByZXR1cm4gYXdhaXQgYWNxdWlyZShidWNrZXQsIGFtb3VudCk7XG4gICAgfVxuICB9XG5cbiAgYnVja2V0LmFsbG93QWNxdWlyZSA9IGZhbHNlO1xuICAvLyBTaW5jZSB0aGUgYnVja2V0IGlzIGxhenkgdXBkYXRlIHRoZSB0b2tlbnMgbm93LFxuICAvLyBhbmQgYWxzbyBnZXQgdGhlIGN1cnJlbnQgYW1vdW50IG9mIGF2YWlsYWJsZSB0b2tlbnNcbiAgbGV0IGN1cnJlbnRUb2tlbnMgPSB1cGRhdGVUb2tlbnMoYnVja2V0KTtcblxuICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgbW9yZSB0aGFuIGF2YWlsYWJsZSB0b2tlbnMgaGF2ZSBiZWVuIGFjcXVpcmVkLFxuICAvLyBzbyBjYWxjdWxhdGUgdGhlIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCB1bnRpbCB0aGlzIGFjcXVpcmUgaXMgZ29vZCB0byBnby5cbiAgaWYgKGN1cnJlbnRUb2tlbnMgPCBhbW91bnQpIHtcbiAgICBjb25zdCB0b2tlbnNOZWVkZWQgPSBhbW91bnQgLSBjdXJyZW50VG9rZW5zO1xuICAgIGxldCByZWZpbGxzTmVlZGVkID0gTWF0aC5jZWlsKHRva2Vuc05lZWRlZCAvIGJ1Y2tldC5yZWZpbGxBbW91bnQpO1xuXG4gICAgY29uc3Qgd2FpdFRpbWUgPSBidWNrZXQucmVmaWxsSW50ZXJ2YWwgKiByZWZpbGxzTmVlZGVkO1xuICAgIGF3YWl0IGRlbGF5KHdhaXRUaW1lKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgdG9rZW5zIGFnYWluIHRvIGVuc3VyZSBub3RoaW5nIGhhcyBiZWVuIG1pc3NlZC5cbiAgICB1cGRhdGVUb2tlbnMoYnVja2V0KTtcbiAgfVxuXG4gIC8vIEluIG9yZGVyIHRvIG5vdCBzdWJ0cmFjdCB0b28gbXVjaCBmcm9tIHRoZSB0b2tlbnMsXG4gIC8vIGNhbGN1bGF0ZSB3aGF0IGlzIGFjdHVhbGx5IG5lZWRlZCB0byBzdWJ0cmFjdC5cbiAgY29uc3QgdG9TdWJ0cmFjdCA9IChhbW91bnQgJSBidWNrZXQucmVmaWxsQW1vdW50KSB8fCBhbW91bnQ7XG4gIGJ1Y2tldC50b2tlbnNTdGF0ZSAtPSB0b1N1YnRyYWN0O1xuXG4gIC8vIEFsbG93IHRoZSBuZXh0IGFjcXVpcmUgdG8gaGFwcGVuLlxuICBidWNrZXQuYWxsb3dBY3F1aXJlID0gdHJ1ZTtcbiAgLy8gSWYgdGhlcmUgaXMgYW4gYWNxdWlyZSB3YWl0aW5nLCBsZXQgaXQgY29udGludWUuXG4gIGJ1Y2tldC53YWl0aW5nLnNoaWZ0KCk/LigpO1xufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLFNBQVMsS0FBSyxRQUFRLFlBQVksQ0FBQztBQStEbkMsT0FBTyxTQUFTLGlCQUFpQixDQUMvQixFQUFFLEdBQUcsQ0FBQSxFQUFFLGNBQWMsQ0FBQSxFQUFFLFlBQVksQ0FBQSxFQUFFLE1BQU0sQ0FBQSxFQUFFLE9BQU8sQ0FBQSxFQUFFLEdBQUcsSUFBSSxFQWExRCxFQUNVO0lBQ2IsT0FBTztRQUNMLEdBQUc7UUFDSCxjQUFjO1FBQ2QsWUFBWSxFQUFFLFlBQVksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLFlBQVk7UUFDckQsVUFBVSxFQUFFLFdBQVcsQ0FBQyxHQUFHLEVBQUU7UUFDN0IsWUFBWSxFQUFFLElBQUk7UUFFbEIsVUFBVSxFQUFFLFdBQVk7WUFDdEIsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDekI7UUFFRCxNQUFNLEVBQUUsV0FBWTtZQUNsQixPQUFPLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUMzQjtRQUVELE9BQU8sRUFBRSxlQUFnQixNQUFNLEVBQUUsWUFBWSxFQUFFO1lBQzdDLE9BQU8sTUFBTSxPQUFPLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxZQUFZLENBQUMsQ0FBQztTQUNsRDtRQUVELFdBQVcsRUFBRSxNQUFNLElBQUksR0FBRztRQUMxQixPQUFPLEVBQUUsT0FBTyxJQUFJLEVBQUU7UUFFdEIsR0FBRyxJQUFJO0tBQ1IsQ0FBQztDQUNIO0FBRUQ7O0dBRUcsQ0FDSCxTQUFTLFlBQVksQ0FBQyxNQUFtQixFQUFVO0lBQ2pELE1BQU0sVUFBVSxHQUFHLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxNQUFNLENBQUMsVUFBVSxBQUFDO0lBQ3pELE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUMsQUFBQztJQUVyRSx3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